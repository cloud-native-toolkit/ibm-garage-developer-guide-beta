{"componentChunkName":"component---src-pages-guides-argocd-index-mdx","path":"/guides/argocd/","result":{"pageContext":{"frontmatter":{"title":"Continuous Delivery with GitOps"},"relativePagePath":"/guides/argocd/index.mdx","titleType":"page","MdxNode":{"id":"6f74dbb9-ac97-5445-9f90-5f96ee9275e1","children":[],"parent":"6fd87135-e68c-5754-ba64-9c8b2657bae6","internal":{"content":"---\ntitle: Continuous Delivery with GitOps\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nUse GitOps to continuously deliver application changes\n\n</PageDescription>\n\nIn IBM Garage Method, one of the **Develop** practices is [continuous delivery](https://www.ibm.com/garage/method/practices/deliver/practice_continuous_delivery/). \nA preferred model for implementing continuous delivery is GitOps, where the desired state of the operational environment\nis defined in a source control repository (namely Git). \n\n## What is continuous delivery\n\nContinuous delivery is the DevOps approach of frequently making new versions of an application's components available for\ndeployment to a runtime environment. The process involves automation of the build and validation process and concludes \nwith a new version of the application that is available for promotion to another environment.\n\nContinuous delivery is closely related to continuous deployment. The distinction is:\n- Continuous delivery deploys an application when a user manually triggers deployment\n- Continuous deployment deploys an application automatically when it is ready\n\nTypically, continuous deployment is an evolution of a continuous delivery process. An application is ready for \ndeployment when it passes a set of tests that prove it doesn't contain any significant problems. Once these tests have been \nautomated in a way that reliably verifies the application components then the deployment can be automated. Additionally,\nfor continuous delivery it important to employ other best practices around moving and managing changes in an environment: \nblue-green deployments, shadow deployments, and feature toggles to name a few. Until these practices are in place and \nverified, it is best to stick with continuous delivery. \n\nAs with most cloud-native practices, the move from continuous deployment to continuous delivery would not be done in\na \"big bang\" but incrementally and as different application components are ready. \n\n### What is GitOps\n\n[*GitOps*](https://www.weave.works/technologies/gitops/) is the operational pattern of using source code repositories \n(namely Git) as the source of truth for defining the configuration that makes up the desired state of the operational \nenvironment. Git repositories are used to declaratively represent the desired state of applications in deployment \nenvironments.\n\nGitOps takes advantage of several Git features:\n- Git provides a versioned history of changes, listing what was changed and who made the change\n- Change releases can be managed from a pull request, allowing multiple people to make changes but a select few to approve the changes\n- Git provides access control mechanisms to limit who can change and view the configuration\n- Git enables changes to be rolled back quickly if there is an issue with a new release\n- Git supports multiple models for change management: Branches, Forks, GitFlow, etc\n- Hosted git providers (like GitHub) provide a rich API that allows the different operations to be automated, if desired\n\n### CI/CD integration\n\nFor the full end-to-end build and delivery process, both the CI and CD pipelines are used. When working in\na containerized environment such as <Globals name=\"kube\" /> or <Globals name=\"ocp\" />, the responsibilities between the \ntwo processes are clearly defined:\n\n- The **CI pipeline** is responsible for building validating and packaging the \"raw materials\" (source code, deployment \nconfiguration, etc) into versioned, deployable artifacts (container images, helm charts, published artifacts, etc)\n- The **CD pipeline** is responsible for applying the deployable artifacts into a particular target environment\n\n![Argo CD config](./images/CI_CD-pipelines.png)\n\n1. A change made to one of the source repositories triggers the CI process.\n\n2. The CI process builds, validates, and packages those changes into deployable artifacts that are stored in the image\nregistry and artifact repository(ies).\n\n3. The last step of the CI process updates the GitOps repository with information about the updated artifacts. \n\n    At a minimum this step stores updates the version number to the newly released versions of the artifacts but depending on the environment this step might also update the deployment configuration.\n    \n    <InlineNotification>\n    \n    It is also possible to trigger a process when a new image is available in the image registry or a new artifact is available\n    to the artifact management system. \n    \n    In this case, the CI process could be split into two parts: **1)** create the \n    container image and artifacts, and **2)** update the GitOps repo with the available artifacts.\n    \n    </InlineNotification>\n\n## What is Argo CD\n\n[Argo CD](https://argoproj.github.io/argo-cd/) is a declarative, GitOps continuous delivery tool for Kubernetes. The \ndeployment environment is a namespace in a Kubernetes cluster, which also works for an OpenShift cluster or project. \nArgo CD models a collection of applications as a project and uses a Git repository to store the project's desired state. \nArgo CD if flexible in how the application configuration is stored in the Git repository. The only requirement is that\nthe application information is stored somewhere in a Git repository.\n\nArgo CD supports defining Kubernetes manifests in a number of ways:\n- helm charts\n- kustomize\n- ksonnet\n- jsonnet\n- plain directory of yaml/json manifests\n\nArgo CD synchronizes the application state with the desired state defined in Git and automates the deployment of Kubernetes resources to ensure they match.\n\n## Configuring GitOps with Argo CD\n\nYou must have completed the [Argo CD Setup](/admin/artifactory-setup) before continuing.\n\n**Terminology:**\n\nArgo CD uses a number of terms to refer to the components\n\n- Application - A deployable unit\n\n    In the context of the <Globals name=\"env\" />, an application is one Helm chart that contains one container image that was produced by one CI pipeline. While Helm charts and images could certainly be combined to make more sophisticated applications in more advanced scenarios, we will be using this simple definition here.\n    \n- Project - A collection of applications that make up a solution\n\n### Set up the GitOps repo\n\nArgo CD uses a Git repo to express the desired state of the Kubernetes environment. The basic setup uses one repository to represent one [*project*](https://argoproj.github.io/argo-cd/user-guide/projects/). Within that repository, each [*application*](https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#applications) that makes up the project will be described in its own folder. The repository will also contain a branch for each destination (i.e. cluster and namespace) into which we want to deploy the applications.\n\n1. Create a new repo from the [Argo CD <Globals name=\"template\" />](https://github.com/IBM/template-argocd-gitops/generate)\n\n1. Clone the project to your machine\n\n1. Create a branch for the environment (e.g. `test` to configure the values for deployment to the testing environment)\n\n    ```bash\n    git checkout -b test\n    ```\n\n1. The repository contains a template Helm chart in the `app-artifactory` folder. Copy that folder and rename it to match one of\nthe application names in your project, i.e. `{app repo}`.\n\n   The application name should match the repository name if the CI pipeline is going push changes to the CD pipeline.\n\n1. Update `Chart.yaml`\n\n   - `name` - The name of the application, should match the folder from the previous step\n\n1. Update `requirements.yaml`\n\n    - `name` - The name of Helm chart and Docker image, should match your Git repo name, i.e. `{app repo}`\n    - `version` - The version number of the Helm chart, i.e. `{chart version}`\n    - `repository` - The url to the Helm repository including the folder where the Helm charts are being stored, i.e. `http://artifactory.{ingress subdomain}/artifactory/generic-local/`\n\n        The url of the Helm repository in Artifactory can be determined by following the steps described in [Administrator Guide - Argo CD setup](/admin/argocd-setup/#get-the-helm-repository-location).\n\n1. Update `values.yaml`\n \n    - Replace `<app-chart-name>` with the name of application\n    - Provide configuration values specific to the Helm chart under the `<app-chart-name>` prefix\n\n    **Note:** The Helm values will need to be prefixed with the Helm chart name that was provided in the previous step. For example, assuming the helm chart is `message-logger`, the values.yaml file would look like the following:\n    ```yaml\n    message-logger:\n      replicaCount: 3\n    ``` \n   **Note:** The specific values that should be configured are dependent on the Helm chart that is referenced in the `requirements.yaml`. For the <Globals name=\"templates\" />, you can see those details and customize the chart by looking in the `chart/{chart name}` of the repository.\n\n1. Repeat steps 4-7 for each application in the project\n\n### Register the git repo in Argo CD\n\nNow that the repository has been created, we need to tell Argo CD where it is.\n\n1. Get the Argo CD login information from the `igc credentials` CLI command\n\n    **Note:** You need to be logged into the cluster on the command-line for the CLI to access the cluster information.\n\n1. Log in to Argo CD\n\n1. Click on the gear icon on the left menu to access the Settings options\n\n    ![Argo CD config](/images/argocd-config.png)\n\n1. Select the `Repositories` option\n\n1. Press either the Connect Repo using HTTPS or Connect Repo using SSH button at the top and provide the information\nfor the Git repo\n\n### Create a project in Argo CD (Optional)\n\nIn Argo CD terms, each deployable component is an application and applications are grouped into projects. Projects are not\nrequired for Argo CD to be able to deploy applications, but it helps to organize applications and provide some restrictions\non what can be done for applications that make up a project.\n\nTo create a project:\n\n1. Log into Argo CD\n\n1. Click on the gear icon on the left menu to access the Settings options\n\n    ![Argo CD config](/images/argocd-config.png)\n\n1. Select the Projects option\n\n1. Press the New Project button at the top of the page\n\n1. Specify the properties for the new project\n\n    - name - Provide the name for the project\n    - description - A brief description of the project\n    - source - Press Add source and pick the Git repository from the list that was added previously\n    - destinations\n        - Add `https://kubernetes.default.svc` for the cluster url and `test` for the namespace\n        - Add `https://kubernetes.default.svc` for the cluster url and `staging` for the namespace\n    - Press Create\n\n    **Note:** Initially, the only cluster that is available is the one in which Argo CD is -\n    `https://kubernetes.default.svc`. By adding the two destinations we have allowed the project to be deployed\n    to both the `test` and `staging` namespaces within the current cluster.\n\n### Add an application in Argo CD for each application component (Helm chart)\n\nThe last step in the process is to define the application(s) within Argo CD that should be managed. This consists of\nconnecting the config within the Git repo to the cluster and namespace.\n\n1. Log into Argo CD\n\n1. Press `New Application` and provide the following values:\n\n    - `application name` - The name of the application. It is recommend to use the format of `{namespace}-{image name}`\n    - `project` - The project with which the application should be included\n    - `sync-policy` - The manner with which Argo CD will use to manage the deployed artifacts. `Automatic` is\n    recommended\n    - `repository url` - The Git url where the configuration is stored\n    - `revision` - The branch where the configuration for this instance is stored\n    - `path` - The path within the repository where the application config is located (should be the application name)\n    - `destination cluster` - The cluster url for the deployment\n    - `destination namespace` - The namespace where the application should be deployed\n\n1. Repeat that step for each application and each environment\n\n### Hook the CI pipeline to the CD pipeline\n\nThe last stage in the CI pipeline updates the version number in the `requirements.yaml` to the version of the helm chart\nthat was just built. Through a couple naming conventions the only thing the pipeline needs in order to interact\nwith the CD process is a Kubernetes secret named `gitops-cd-secret` that provides the details needed\nto connect to the git repo to push updates.\n\nFortunately, a CLI command provides a simple way to create a Kubernetes secret\nthat contains git credentials.\n\nCreate the `gitops-cd-secret`:\n\n1. Log into the cluster on the command-line.\n\n1. Change the directory to the root of the Argo CD <Globals name=\"template\" /> repo that was cloned previously.\n\n1. Run `igc git-secret gitops-repo -n dev-{initials}` to create the secret. This command will prompt for the username, personal access token, and the branch to put in the secret.\n\n#### What just happened?\n\nThe `git-secret` command creates a secret in a Kubernetes namespace containing the url, username, password, and branch information for a git repo. In the command above, we provided `gitops-cd-secret` for the secret name. (If that value is left off the secret name defaults to `{git org}.{git repo}`.) You can verify the secret was created by running:\n\n```bash\nkubectl get secrets/gitops-cd-secret -n dev-{initials} -o yaml\n```\n\n**Note:**\n\n- For the secret to be available to the CI pipeline, the secret needs to be created in the same namespace where the pipeline is running (e.g. `dev-{initials}`).\n- The value provided for `branch` is the one the pipeline will use to when committing changes to trigger the CD pipeline. `test` is the recommended value for the branch field.\n","type":"Mdx","contentDigest":"8418207c3f482929896d99c46a8d4aad","counter":933,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Continuous Delivery with GitOps"},"exports":{},"rawBody":"---\ntitle: Continuous Delivery with GitOps\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nUse GitOps to continuously deliver application changes\n\n</PageDescription>\n\nIn IBM Garage Method, one of the **Develop** practices is [continuous delivery](https://www.ibm.com/garage/method/practices/deliver/practice_continuous_delivery/). \nA preferred model for implementing continuous delivery is GitOps, where the desired state of the operational environment\nis defined in a source control repository (namely Git). \n\n## What is continuous delivery\n\nContinuous delivery is the DevOps approach of frequently making new versions of an application's components available for\ndeployment to a runtime environment. The process involves automation of the build and validation process and concludes \nwith a new version of the application that is available for promotion to another environment.\n\nContinuous delivery is closely related to continuous deployment. The distinction is:\n- Continuous delivery deploys an application when a user manually triggers deployment\n- Continuous deployment deploys an application automatically when it is ready\n\nTypically, continuous deployment is an evolution of a continuous delivery process. An application is ready for \ndeployment when it passes a set of tests that prove it doesn't contain any significant problems. Once these tests have been \nautomated in a way that reliably verifies the application components then the deployment can be automated. Additionally,\nfor continuous delivery it important to employ other best practices around moving and managing changes in an environment: \nblue-green deployments, shadow deployments, and feature toggles to name a few. Until these practices are in place and \nverified, it is best to stick with continuous delivery. \n\nAs with most cloud-native practices, the move from continuous deployment to continuous delivery would not be done in\na \"big bang\" but incrementally and as different application components are ready. \n\n### What is GitOps\n\n[*GitOps*](https://www.weave.works/technologies/gitops/) is the operational pattern of using source code repositories \n(namely Git) as the source of truth for defining the configuration that makes up the desired state of the operational \nenvironment. Git repositories are used to declaratively represent the desired state of applications in deployment \nenvironments.\n\nGitOps takes advantage of several Git features:\n- Git provides a versioned history of changes, listing what was changed and who made the change\n- Change releases can be managed from a pull request, allowing multiple people to make changes but a select few to approve the changes\n- Git provides access control mechanisms to limit who can change and view the configuration\n- Git enables changes to be rolled back quickly if there is an issue with a new release\n- Git supports multiple models for change management: Branches, Forks, GitFlow, etc\n- Hosted git providers (like GitHub) provide a rich API that allows the different operations to be automated, if desired\n\n### CI/CD integration\n\nFor the full end-to-end build and delivery process, both the CI and CD pipelines are used. When working in\na containerized environment such as <Globals name=\"kube\" /> or <Globals name=\"ocp\" />, the responsibilities between the \ntwo processes are clearly defined:\n\n- The **CI pipeline** is responsible for building validating and packaging the \"raw materials\" (source code, deployment \nconfiguration, etc) into versioned, deployable artifacts (container images, helm charts, published artifacts, etc)\n- The **CD pipeline** is responsible for applying the deployable artifacts into a particular target environment\n\n![Argo CD config](./images/CI_CD-pipelines.png)\n\n1. A change made to one of the source repositories triggers the CI process.\n\n2. The CI process builds, validates, and packages those changes into deployable artifacts that are stored in the image\nregistry and artifact repository(ies).\n\n3. The last step of the CI process updates the GitOps repository with information about the updated artifacts. \n\n    At a minimum this step stores updates the version number to the newly released versions of the artifacts but depending on the environment this step might also update the deployment configuration.\n    \n    <InlineNotification>\n    \n    It is also possible to trigger a process when a new image is available in the image registry or a new artifact is available\n    to the artifact management system. \n    \n    In this case, the CI process could be split into two parts: **1)** create the \n    container image and artifacts, and **2)** update the GitOps repo with the available artifacts.\n    \n    </InlineNotification>\n\n## What is Argo CD\n\n[Argo CD](https://argoproj.github.io/argo-cd/) is a declarative, GitOps continuous delivery tool for Kubernetes. The \ndeployment environment is a namespace in a Kubernetes cluster, which also works for an OpenShift cluster or project. \nArgo CD models a collection of applications as a project and uses a Git repository to store the project's desired state. \nArgo CD if flexible in how the application configuration is stored in the Git repository. The only requirement is that\nthe application information is stored somewhere in a Git repository.\n\nArgo CD supports defining Kubernetes manifests in a number of ways:\n- helm charts\n- kustomize\n- ksonnet\n- jsonnet\n- plain directory of yaml/json manifests\n\nArgo CD synchronizes the application state with the desired state defined in Git and automates the deployment of Kubernetes resources to ensure they match.\n\n## Configuring GitOps with Argo CD\n\nYou must have completed the [Argo CD Setup](/admin/artifactory-setup) before continuing.\n\n**Terminology:**\n\nArgo CD uses a number of terms to refer to the components\n\n- Application - A deployable unit\n\n    In the context of the <Globals name=\"env\" />, an application is one Helm chart that contains one container image that was produced by one CI pipeline. While Helm charts and images could certainly be combined to make more sophisticated applications in more advanced scenarios, we will be using this simple definition here.\n    \n- Project - A collection of applications that make up a solution\n\n### Set up the GitOps repo\n\nArgo CD uses a Git repo to express the desired state of the Kubernetes environment. The basic setup uses one repository to represent one [*project*](https://argoproj.github.io/argo-cd/user-guide/projects/). Within that repository, each [*application*](https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#applications) that makes up the project will be described in its own folder. The repository will also contain a branch for each destination (i.e. cluster and namespace) into which we want to deploy the applications.\n\n1. Create a new repo from the [Argo CD <Globals name=\"template\" />](https://github.com/IBM/template-argocd-gitops/generate)\n\n1. Clone the project to your machine\n\n1. Create a branch for the environment (e.g. `test` to configure the values for deployment to the testing environment)\n\n    ```bash\n    git checkout -b test\n    ```\n\n1. The repository contains a template Helm chart in the `app-artifactory` folder. Copy that folder and rename it to match one of\nthe application names in your project, i.e. `{app repo}`.\n\n   The application name should match the repository name if the CI pipeline is going push changes to the CD pipeline.\n\n1. Update `Chart.yaml`\n\n   - `name` - The name of the application, should match the folder from the previous step\n\n1. Update `requirements.yaml`\n\n    - `name` - The name of Helm chart and Docker image, should match your Git repo name, i.e. `{app repo}`\n    - `version` - The version number of the Helm chart, i.e. `{chart version}`\n    - `repository` - The url to the Helm repository including the folder where the Helm charts are being stored, i.e. `http://artifactory.{ingress subdomain}/artifactory/generic-local/`\n\n        The url of the Helm repository in Artifactory can be determined by following the steps described in [Administrator Guide - Argo CD setup](/admin/argocd-setup/#get-the-helm-repository-location).\n\n1. Update `values.yaml`\n \n    - Replace `<app-chart-name>` with the name of application\n    - Provide configuration values specific to the Helm chart under the `<app-chart-name>` prefix\n\n    **Note:** The Helm values will need to be prefixed with the Helm chart name that was provided in the previous step. For example, assuming the helm chart is `message-logger`, the values.yaml file would look like the following:\n    ```yaml\n    message-logger:\n      replicaCount: 3\n    ``` \n   **Note:** The specific values that should be configured are dependent on the Helm chart that is referenced in the `requirements.yaml`. For the <Globals name=\"templates\" />, you can see those details and customize the chart by looking in the `chart/{chart name}` of the repository.\n\n1. Repeat steps 4-7 for each application in the project\n\n### Register the git repo in Argo CD\n\nNow that the repository has been created, we need to tell Argo CD where it is.\n\n1. Get the Argo CD login information from the `igc credentials` CLI command\n\n    **Note:** You need to be logged into the cluster on the command-line for the CLI to access the cluster information.\n\n1. Log in to Argo CD\n\n1. Click on the gear icon on the left menu to access the Settings options\n\n    ![Argo CD config](/images/argocd-config.png)\n\n1. Select the `Repositories` option\n\n1. Press either the Connect Repo using HTTPS or Connect Repo using SSH button at the top and provide the information\nfor the Git repo\n\n### Create a project in Argo CD (Optional)\n\nIn Argo CD terms, each deployable component is an application and applications are grouped into projects. Projects are not\nrequired for Argo CD to be able to deploy applications, but it helps to organize applications and provide some restrictions\non what can be done for applications that make up a project.\n\nTo create a project:\n\n1. Log into Argo CD\n\n1. Click on the gear icon on the left menu to access the Settings options\n\n    ![Argo CD config](/images/argocd-config.png)\n\n1. Select the Projects option\n\n1. Press the New Project button at the top of the page\n\n1. Specify the properties for the new project\n\n    - name - Provide the name for the project\n    - description - A brief description of the project\n    - source - Press Add source and pick the Git repository from the list that was added previously\n    - destinations\n        - Add `https://kubernetes.default.svc` for the cluster url and `test` for the namespace\n        - Add `https://kubernetes.default.svc` for the cluster url and `staging` for the namespace\n    - Press Create\n\n    **Note:** Initially, the only cluster that is available is the one in which Argo CD is -\n    `https://kubernetes.default.svc`. By adding the two destinations we have allowed the project to be deployed\n    to both the `test` and `staging` namespaces within the current cluster.\n\n### Add an application in Argo CD for each application component (Helm chart)\n\nThe last step in the process is to define the application(s) within Argo CD that should be managed. This consists of\nconnecting the config within the Git repo to the cluster and namespace.\n\n1. Log into Argo CD\n\n1. Press `New Application` and provide the following values:\n\n    - `application name` - The name of the application. It is recommend to use the format of `{namespace}-{image name}`\n    - `project` - The project with which the application should be included\n    - `sync-policy` - The manner with which Argo CD will use to manage the deployed artifacts. `Automatic` is\n    recommended\n    - `repository url` - The Git url where the configuration is stored\n    - `revision` - The branch where the configuration for this instance is stored\n    - `path` - The path within the repository where the application config is located (should be the application name)\n    - `destination cluster` - The cluster url for the deployment\n    - `destination namespace` - The namespace where the application should be deployed\n\n1. Repeat that step for each application and each environment\n\n### Hook the CI pipeline to the CD pipeline\n\nThe last stage in the CI pipeline updates the version number in the `requirements.yaml` to the version of the helm chart\nthat was just built. Through a couple naming conventions the only thing the pipeline needs in order to interact\nwith the CD process is a Kubernetes secret named `gitops-cd-secret` that provides the details needed\nto connect to the git repo to push updates.\n\nFortunately, a CLI command provides a simple way to create a Kubernetes secret\nthat contains git credentials.\n\nCreate the `gitops-cd-secret`:\n\n1. Log into the cluster on the command-line.\n\n1. Change the directory to the root of the Argo CD <Globals name=\"template\" /> repo that was cloned previously.\n\n1. Run `igc git-secret gitops-repo -n dev-{initials}` to create the secret. This command will prompt for the username, personal access token, and the branch to put in the secret.\n\n#### What just happened?\n\nThe `git-secret` command creates a secret in a Kubernetes namespace containing the url, username, password, and branch information for a git repo. In the command above, we provided `gitops-cd-secret` for the secret name. (If that value is left off the secret name defaults to `{git org}.{git repo}`.) You can verify the secret was created by running:\n\n```bash\nkubectl get secrets/gitops-cd-secret -n dev-{initials} -o yaml\n```\n\n**Note:**\n\n- For the secret to be available to the CI pipeline, the secret needs to be created in the same namespace where the pipeline is running (e.g. `dev-{initials}`).\n- The value provided for `branch` is the one the pipeline will use to when committing changes to trigger the CD pipeline. `test` is the recommended value for the branch field.\n","fileAbsolutePath":"/home/runner/work/ibm-garage-developer-guide/ibm-garage-developer-guide/src/pages/guides/argocd/index.mdx"}}},"staticQueryHashes":["1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","2982904675","3018647132","3018647132","3037994772","3037994772","63531786","63531786","768070550"]}